import { DiscoveredInsight } from '../adaptive-questions/adaptive-engine';
import { ExplorationSuggestion } from '../predictions/hidden-interest-predictor';
import { RawJob, ScoredJob } from '@/types/job';
import { UserProfile } from '@/types/user-profile';

export interface DiscoverySearchTerm {
  term: string;
  source: string;
  insightId: string;
  confidence: number;
  isNew: boolean;
  category: 'role' | 'skill' | 'value' | 'industry' | 'work-style';
}

export interface DiscoveryFilter {
  type: 'remote' | 'location' | 'experience-level' | 'company-size' | 'industry' | 'keywords';
  value: string | string[];
  reason: string;
  basedOnInsight: string;
  active: boolean;
}

export interface DiscoveryMatchBadge {
  type: 'insight-match' | 'hidden-interest' | 'strength-match' | 'preference-fit';
  label: string;
  color: 'green' | 'blue' | 'purple' | 'cyan';
  confidence: number;
  explanation: string;
}

export interface EnrichedJob extends ScoredJob {
  discoveryMatches: DiscoveryMatchBadge[];
  discoveryScore: number;
  matchedInsights: string[];
  autoGeneratedSearchTerms: string[];
}

export interface JobAlert {
  id: string;
  type: 'new-insight' | 'hidden-interest' | 'preference-change';
  title: string;
  message: string;
  searchTerms: string[];
  createdAt: Date;
  triggered: boolean;
}

export class LiveDiscoveryJobMatcher {
  private searchTerms: Map<string, DiscoverySearchTerm> = new Map();
  private filters: DiscoveryFilter[] = [];
  private alerts: JobAlert[] = [];
  private previousInsightCount: number = 0;

  constructor(
    private insights: DiscoveredInsight[],
    private hiddenInterests: ExplorationSuggestion[],
    private userProfile?: UserProfile
  ) {
    this.updateSearchTerms();
    this.updateFilters();
    this.checkForNewAlerts();
  }

  private updateSearchTerms() {
    const newTerms: DiscoverySearchTerm[] = [];

    for (const insight of this.insights) {
      const terms = this.extractSearchTermsFromInsight(insight);
      for (const term of terms) {
        const existing = this.searchTerms.get(term.term);
        if (!existing) {
          term.isNew = this.previousInsightCount > 0;
          newTerms.push(term);
        }
        this.searchTerms.set(term.term, term);
      }
    }

    for (const interest of this.hiddenInterests) {
      const terms = this.extractSearchTermsFromHiddenInterest(interest);
      for (const term of terms) {
        const existing = this.searchTerms.get(term.term);
        if (!existing) {
          term.isNew = true;
          newTerms.push(term);
        }
        this.searchTerms.set(term.term, term);
      }
    }

    if (newTerms.length > 0) {
      this.createSearchTermAlert(newTerms);
    }
  }

  private extractSearchTermsFromInsight(insight: DiscoveredInsight): DiscoverySearchTerm[] {
    const terms: DiscoverySearchTerm[] = [];
    const insightLower = insight.insight.toLowerCase();

    if (insightLower.includes('autonomous') || insightLower.includes('independent')) {
      terms.push({
        term: 'independent',
        source: insight.insight,
        insightId: `insight-${insight.area}-${insight.type}`,
        confidence: insight.confidence,
        isNew: false,
        category: 'work-style',
      });
    }

    if (insightLower.includes('collaborative') || insightLower.includes('team')) {
      terms.push({
        term: 'collaborative',
        source: insight.insight,
        insightId: `insight-${insight.area}-${insight.type}`,
        confidence: insight.confidence,
        isNew: false,
        category: 'work-style',
      });
    }

    if (insightLower.includes('data') || insightLower.includes('analytical')) {
      terms.push({
        term: 'data-driven',
        source: insight.insight,
        insightId: `insight-${insight.area}-${insight.type}`,
        confidence: insight.confidence,
        isNew: false,
        category: 'skill',
      });
    }

    if (insightLower.includes('creative') || insightLower.includes('design')) {
      terms.push({
        term: 'creative',
        source: insight.insight,
        insightId: `insight-${insight.area}-${insight.type}`,
        confidence: insight.confidence,
        isNew: false,
        category: 'work-style',
      });
    }

    if (insightLower.includes('marketing') || insightLower.includes('communication')) {
      terms.push({
        term: 'marketing',
        source: insight.insight,
        insightId: `insight-${insight.area}-${insight.type}`,
        confidence: insight.confidence,
        isNew: false,
        category: 'industry',
      });
    }

    if (insightLower.includes('health') || insightLower.includes('wellness')) {
      terms.push({
        term: 'healthcare',
        source: insight.insight,
        insightId: `insight-${insight.area}-${insight.type}`,
        confidence: insight.confidence,
        isNew: false,
        category: 'industry',
      });
    }

    if (insightLower.includes('remote') || insightLower.includes('flexible')) {
      terms.push({
        term: 'remote',
        source: insight.insight,
        insightId: `insight-${insight.area}-${insight.type}`,
        confidence: insight.confidence,
        isNew: false,
        category: 'work-style',
      });
    }

    return terms;
  }

  private extractSearchTermsFromHiddenInterest(interest: ExplorationSuggestion): DiscoverySearchTerm[] {
    const terms: DiscoverySearchTerm[] = [];

    terms.push({
      term: interest.careerArea,
      source: interest.reasoning,
      insightId: `hidden-${interest.careerArea}`,
      confidence: interest.confidence,
      isNew: true,
      category: 'role',
    });

    for (const role of interest.specificRoles) {
      terms.push({
        term: role,
        source: interest.reasoning,
        insightId: `hidden-${interest.careerArea}`,
        confidence: interest.confidence,
        isNew: true,
        category: 'role',
      });
    }

    return terms;
  }

  private updateFilters() {
    this.filters = [];

    const remotePreference = this.insights.find(i =>
      i.insight.toLowerCase().includes('remote') || i.insight.toLowerCase().includes('flexible')
    );

    if (remotePreference && remotePreference.confidence >= 0.7) {
      this.filters.push({
        type: 'remote',
        value: 'true',
        reason: 'Strong preference for remote work',
        basedOnInsight: remotePreference.insight,
        active: true,
      });
    }

    if (this.userProfile?.location) {
      const locationPreference = this.insights.find(i =>
        i.insight.toLowerCase().includes('location') || i.insight.toLowerCase().includes('local')
      );

      if (!remotePreference || remotePreference.confidence < 0.7) {
        this.filters.push({
          type: 'location',
          value: this.userProfile.location,
          reason: 'Based on your current location preference',
          basedOnInsight: locationPreference?.insight || 'User profile location',
          active: true,
        });
      }
    }

    const industryTerms = Array.from(this.searchTerms.values())
      .filter(t => t.category === 'industry' && t.confidence >= 0.7)
      .map(t => t.term);

    if (industryTerms.length > 0) {
      this.filters.push({
        type: 'industry',
        value: industryTerms,
        reason: 'Based on your discovered industry interests',
        basedOnInsight: 'Multiple insights',
        active: true,
      });
    }

    const workStyleKeywords = Array.from(this.searchTerms.values())
      .filter(t => t.category === 'work-style' && t.confidence >= 0.6)
      .map(t => t.term);

    if (workStyleKeywords.length > 0) {
      this.filters.push({
        type: 'keywords',
        value: workStyleKeywords,
        reason: 'Match your preferred work style',
        basedOnInsight: 'Work style preferences',
        active: true,
      });
    }
  }

  private checkForNewAlerts() {
    const newInsights = this.insights.length - this.previousInsightCount;

    if (newInsights > 0) {
      const recentInsights = this.insights.slice(-newInsights);
      const highConfidenceInsights = recentInsights.filter(i => i.confidence >= 0.75);

      if (highConfidenceInsights.length > 0) {
        const searchTerms = highConfidenceInsights
          .flatMap(i => this.extractSearchTermsFromInsight(i))
          .map(t => t.term);

        this.alerts.push({
          id: `alert-${Date.now()}`,
          type: 'new-insight',
          title: 'New career insights discovered',
          message: `We found ${highConfidenceInsights.length} strong match${highConfidenceInsights.length > 1 ? 'es' : ''} for you. Searching for relevant jobs now.`,
          searchTerms: Array.from(new Set(searchTerms)),
          createdAt: new Date(),
          triggered: false,
        });
      }
    }

    if (this.hiddenInterests.length > 0) {
      const recentInterests = this.hiddenInterests.slice(-2);

      for (const interest of recentInterests) {
        if (interest.confidence >= 0.7) {
          this.alerts.push({
            id: `alert-hidden-${Date.now()}`,
            type: 'hidden-interest',
            title: `Hidden interest discovered: ${interest.careerArea}`,
            message: interest.reasoning,
            searchTerms: [interest.careerArea, ...interest.specificRoles],
            createdAt: new Date(),
            triggered: false,
          });
        }
      }
    }

    this.previousInsightCount = this.insights.length;
  }

  private createSearchTermAlert(newTerms: DiscoverySearchTerm[]) {
    const highConfidenceTerms = newTerms.filter(t => t.confidence >= 0.7);

    if (highConfidenceTerms.length > 0) {
      this.alerts.push({
        id: `alert-terms-${Date.now()}`,
        type: 'preference-change',
        title: 'Search updated with new preferences',
        message: `Added ${highConfidenceTerms.length} new search term${highConfidenceTerms.length > 1 ? 's' : ''} based on your discoveries`,
        searchTerms: highConfidenceTerms.map(t => t.term),
        createdAt: new Date(),
        triggered: false,
      });
    }
  }

  enrichJobs(jobs: RawJob[]): EnrichedJob[] {
    return jobs.map(job => this.enrichJob(job));
  }

  private enrichJob(job: RawJob): EnrichedJob {
    const badges = this.generateDiscoveryBadges(job);
    const discoveryScore = this.calculateDiscoveryScore(job, badges);
    const matchedInsights = this.getMatchedInsights(job);
    const autoGeneratedSearchTerms = this.getAutoGeneratedTermsForJob(job);

    const scoredJob: ScoredJob = {
      ...job,
      score: discoveryScore,
      scoreBreakdown: {
        location: { score: 0, weight: 0, weighted: 0 },
        titleRelevance: { score: 0, weight: 0, weighted: 0 },
        salary: { score: 0, weight: 0, weighted: 0 },
        sourceQuality: { score: 0, weight: 0, weighted: 0 },
        total: discoveryScore,
      },
    };

    return {
      ...scoredJob,
      discoveryMatches: badges,
      discoveryScore,
      matchedInsights,
      autoGeneratedSearchTerms,
    };
  }

  private generateDiscoveryBadges(job: RawJob): DiscoveryMatchBadge[] {
    const badges: DiscoveryMatchBadge[] = [];
    const jobText = `${job.title} ${job.description} ${job.company}`.toLowerCase();

    for (const insight of this.insights) {
      if (insight.confidence < 0.6) continue;

      const terms = this.extractSearchTermsFromInsight(insight);
      const matchingTerms = terms.filter(t => jobText.includes(t.term.toLowerCase()));

      if (matchingTerms.length > 0) {
        badges.push({
          type: 'insight-match',
          label: 'Insight Match',
          color: 'green',
          confidence: insight.confidence,
          explanation: `Matches your "${insight.insight.substring(0, 50)}..." preference`,
        });
        break;
      }
    }

    for (const interest of this.hiddenInterests) {
      if (interest.confidence < 0.65) continue;

      const matchesCareerArea = jobText.includes(interest.careerArea.toLowerCase());
      const matchesRole = interest.specificRoles.some(role =>
        jobText.includes(role.toLowerCase())
      );

      if (matchesCareerArea || matchesRole) {
        badges.push({
          type: 'hidden-interest',
          label: 'Hidden Interest',
          color: 'purple',
          confidence: interest.confidence,
          explanation: `Matches your newly discovered interest in ${interest.careerArea}`,
        });
        break;
      }
    }

    const strengthTerms = Array.from(this.searchTerms.values())
      .filter(t => t.category === 'skill' && t.confidence >= 0.7);

    const matchingStrengths = strengthTerms.filter(t =>
      jobText.includes(t.term.toLowerCase())
    );

    if (matchingStrengths.length > 0) {
      badges.push({
        type: 'strength-match',
        label: 'Strength Match',
        color: 'blue',
        confidence: matchingStrengths[0].confidence,
        explanation: `Utilizes your ${matchingStrengths[0].term} skills`,
      });
    }

    const workStyleTerms = Array.from(this.searchTerms.values())
      .filter(t => t.category === 'work-style' && t.confidence >= 0.6);

    const matchingWorkStyle = workStyleTerms.filter(t =>
      jobText.includes(t.term.toLowerCase())
    );

    if (matchingWorkStyle.length > 0) {
      badges.push({
        type: 'preference-fit',
        label: 'Preference Fit',
        color: 'cyan',
        confidence: matchingWorkStyle[0].confidence,
        explanation: `Aligns with your ${matchingWorkStyle[0].term} preference`,
      });
    }

    return badges;
  }

  private calculateDiscoveryScore(job: RawJob, badges: DiscoveryMatchBadge[]): number {
    if (badges.length === 0) return 0;

    const badgeScores = badges.map(b => b.confidence * 100);
    const avgScore = badgeScores.reduce((sum, score) => sum + score, 0) / badgeScores.length;

    const multiplier = Math.min(1 + (badges.length * 0.1), 1.5);

    return Math.min(avgScore * multiplier, 100);
  }

  private getMatchedInsights(job: RawJob): string[] {
    const matchedInsights: string[] = [];
    const jobText = `${job.title} ${job.description}`.toLowerCase();

    for (const insight of this.insights) {
      const terms = this.extractSearchTermsFromInsight(insight);
      const hasMatch = terms.some(t => jobText.includes(t.term.toLowerCase()));

      if (hasMatch) {
        matchedInsights.push(insight.insight);
      }
    }

    return matchedInsights;
  }

  private getAutoGeneratedTermsForJob(job: RawJob): string[] {
    const jobText = `${job.title} ${job.description}`.toLowerCase();
    const matchingTerms: string[] = [];

    for (const [term, data] of this.searchTerms.entries()) {
      if (jobText.includes(term.toLowerCase())) {
        matchingTerms.push(term);
      }
    }

    return matchingTerms;
  }

  getActiveSearchTerms(): DiscoverySearchTerm[] {
    return Array.from(this.searchTerms.values())
      .filter(t => t.confidence >= 0.6)
      .sort((a, b) => b.confidence - a.confidence);
  }

  getActiveFilters(): DiscoveryFilter[] {
    return this.filters.filter(f => f.active);
  }

  getAlerts(): JobAlert[] {
    return this.alerts.filter(a => !a.triggered);
  }

  markAlertAsTriggered(alertId: string) {
    const alert = this.alerts.find(a => a.id === alertId);
    if (alert) {
      alert.triggered = true;
    }
  }

  getSearchQuery(): string {
    const topTerms = Array.from(this.searchTerms.values())
      .filter(t => t.confidence >= 0.7)
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 5)
      .map(t => t.term);

    return topTerms.join(' OR ');
  }

  updateWithNewInsights(insights: DiscoveredInsight[], hiddenInterests: ExplorationSuggestion[]) {
    this.insights = insights;
    this.hiddenInterests = hiddenInterests;
    this.updateSearchTerms();
    this.updateFilters();
    this.checkForNewAlerts();
  }
}